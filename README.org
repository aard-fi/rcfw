* NoTankS Arduino firmware                                            :TOC_4:
  - [[#introduction][Introduction]]
    - [[#working-features][Working features]]
      - [[#general][General]]
      - [[#notanks][NoTankS]]
    - [[#building][Building]]
    - [[#planned-features][Planned features]]
      - [[#general-1][General]]
      - [[#notanks-1][NoTankS]]
    - [[#required-hardware][Required hardware]]
      - [[#flysky-hardware][Flysky hardware]]
      - [[#elrs-hardware][ELRS hardware]]
  - [[#modified-parts][Modified parts]]
  - [[#rc-hardware][RC hardware]]
    - [[#pistol-grip-elrs-transmitter][Pistol grip ELRS transmitter]]
    - [[#elrs-transmitter][ELRS transmitter]]
    - [[#flysky-transmitter][Flysky transmitter]]
    - [[#6-channel-receivers][6 channel receivers]]
  - [[#wiring][Wiring]]
    - [[#led-groups][LED groups]]
    - [[#elrs-receiver-reset][ELRS receiver reset]]
    - [[#models][Models]]
      - [[#arctic-tinyrider][Arctic Tinyrider]]
      - [[#notanks-2][NoTanks]]
      - [[#rc-benchy][RC Benchy]]
  - [[#transmitter-channels][Transmitter channels]]
    - [[#default-channel-mapping-for-radiomaster-mt12][Default channel mapping for Radiomaster MT12]]
    - [[#default-channel-mapping-for-radiomaster-pocket][Default channel mapping for Radiomaster Pocket]]
    - [[#default-channel-mapping-for-flysky-fs-i6][Default channel mapping for Flysky FS-i6]]

** Introduction

This is a variant of my [[https://github.com/bwachter/arctic_tinyrider][Arctic Tinyrider controller firmware]], trying to support multiple models (including the original one) with compile time switches:

- the [[https://www.printables.com/model/114300-arctic-tinyrider-rc-snowmobile][Arctic Tinyrider RC snowmobile]]
- the [[https://www.thingiverse.com/thing:2789361][NoTankS tank]]
- the [[https://www.printables.com/model/34128-rc-benchy][RC Benchy]]

It should also work without changes for any model either just using two motors, ore one motor and one servo for steering - the upcoming model specific details are mostly about LED effects.

For this variant I've moved to the [[https://store.arduino.cc/products/arduino-nano-every][Arduino Nano Every]] - mainly for the additional UARTs. This is mainly useful for debugging - the RX pin is no longer shared between the iBus receiver and USB serial. The original Nano is still supported, though, and incompatible features (mostly debug logging) get automatically disabled during compilation.

The Every uses the first UART via USB serial, and the second UART via the RX/TX pins (which are used for connecting to the receiver). The older Nano connects its first (and only) UART to both USB serial and the RX/TX pins - so it should be programmed with the rest of the circuit powered down.

This is mostly annoying when actively developing - so for models which only occasionally get updated firmware without active development a generic Nano clone should be sufficient, and way cheaper. At the time of writing a Nano clone (which even has USB C) costs less than 1 EUR, while the original Every goes up to 20 EUR, with clones (which also stick to Micro USB for some reason) selling for roughly 12 EUR.

The only other disadvantage of the original Nano for basic models is the lower serial port speed of 115200 - but that should not be an issue for the type of model this firmware tries to support.

*** Working features
The initial version was written for IBUS receivers - some of the advanced features may not work with CRSF receivers yet.

**** General
- ignition switch: throttle is pinned to zero unless ignition switch is on. This allows somewhat safer handling when not fully switched off. A LED connected to D13 will signal throttle state by blinking (off) or solid light (on).
- throttle and steering (obviously)
- reversing, when supported by the model
- control remapping: a three state switch can be used to change controls. Exact functionality depends on model and transmitter used.
- dynamic speed control: a dial can be used to limit the speed without having to change the throttle curve in the transmitter. In the default setting the transmitter starts with 50% output, and can be set up to 100%. Exact functionality depends on model and transmitter used.
- failsafe requires the ability of the receiver to send sane values when connectivity has been lost. This works well with ELRS receivers, untested with Flysky, though it may be possible with some.
- three groups of LEDs can be used for models in the standard configuration: back/power, front and effect. Any of those LED groups can be set to an arbitrary number of pins from 0 to as many pins are available

Ignition switching, control remapping and dynamic speed control currently can be disabled at compile time to free up channels.

Flysky support will mostly be maintained at the current level, while new features target CRSF. Some rely on ELRS/CRSF behaviour, while others could be enabled somewhat easily for flysky as well. CRSF only features are:

- link detection on startup. The main program will only start running once link has been established
- receiver power cycling. With additional wiring (see below) the receiver can be power cycled on startup. This is recommended, as ELRS receivers go into WiFi configuration mode after some time, and would need manual intervention
- link monitoring with board reset after timeout, configurable at compile time
- remote type detection. With the controls for channel 4 in default position the type of remote (stick or pistol grip) can be auto-detected. This is a compile time setting, which defaults to on.

**** NoTankS
- turning based on accelerating or decelerating one side, depending on the current speed. This also allows turning at zero speed
- curves for low speed cutoff to keep the motors cooler

*** Building

Get the [[https://www.arduino.cc/en/software][Arduino IDE]], and the following libraries:

- the [[https://github.com/arduino-libraries/Servo][servo library]]
- for CRSF use [[https://github.com/AlfredoSystems/AlfredoCRSF][AlfredoCRSF]]
- for IBUS use [[https://github.com/bmellink/IBusBM][IBusBM]]

Configure the correct board (Nano or Nano Every are supported, Every recommended), and go through the defines at the beginning of the file to configure the build for your model and transmitter setup.

*** Planned features
**** General
- steering curve adjustment for controllers with two potis
- toggling ESC power supply/board power supply

**** NoTankS
- optimising the steering to result in as little speed change as possible

*** Required hardware

- one Arduino Nano Every
- one receiver
- one radio
- two ESCs with reverse which use the first PWM input value to configure the zero position. It also should be configurable for forward/reverse - most come in forward/reverse/brake configuration, and not all allow omitting the brake. I'm using the 160A variant from [[https://www.aliexpress.com/item/1005006256842555.html][here]].

**** Flysky hardware

Recommendation here is the FS-A8S as receiver, and an AFHDS 2a transmitter, like the FS-i6. When starting new I'd recommend going for ELRS hardware instead, though.

The main drawback of the FS-A8S is the lack of a second iBus - so we can't send custom telemetry data back to the radio. On the plus side it is a tiny receiver, very cheap (roughly 10 EUR), and can output up to 18 channels via iBus. I'm not aware of receivers of a similar size with more than one iBus - other small Flysky receivers just have more connectors for PWM breakout cables, which we don't need as we're controlling that part via the Arduino.

**** ELRS hardware

Any ELRS transmitter should do, if you're looking for recommendations:

- for a pistol grip style one, Radiomaster MT12
- for a traditional drone/plane one, Radiomaster Boxer M2, or if you want to be fancier, the TX16S
- for a small, more portable one, Radiomaster Pocket

For receivers any of the compact (nano) receivers should be fine, from any manufacturer - as far as I'm aware all of them have RX/TX ports for CRSF. Some of the larger ones do not have that - but the tiny ones are easier to stuff into models anyway.

Main drawbock of ELRS is that the receivers are roughly double the price of AFHDS ones - but for that we always have the ability to send telemetry back.

** Modified parts
For some of the models I've modified parts. You can find those in separate repositories:

- [[https://github.com/bwachter/arctic_tinyrider][Arctic Tinyrider]]
- [[https://github.com/bwachter/notanks/][NoTankS]]

** RC hardware

Both throttle curve and trim settings will change the values sent by the transmitter. Currently the assumption is that for our models we can adjust those settings on the Arduino, so adjusted input may be improperly handled - don't use that.

*** Pistol grip ELRS transmitter
With the default setup of steering at channel 1 and throttle at channel two basic control will work out of the box.

Remapping of throttle and steering is not supported as it does not make much sense with that style of transmitter.

The ignition switch is expected on channel 9.

*** ELRS transmitter
This setup is currently untested, but should be working.

The ignition switch is expected on channel 5, which should be one of the two-state switches in the default configuration.

*** Flysky transmitter
At least the FS-i6 requires extra setup for the switches, see the transmitter section below for details.

The ignition switch is expected on channel 7.

*** 6 channel receivers

VRB is currently not used, so to make this work you need to select three features to drop to free up channels, and disable them at compile time. With ELRS receivers supporting at least 16 channels, and all the cheap AFHDS nano receivers supporting 10 support for running building with less than 10 channels may be dropped eventually.

** Wiring

You'll need one power and one ground bar to connect everything to. A quick and dirty variant is getting ready made jumper wires, cut them and then twist end solder the ends together. On the Arduino connect ground and VIN to ground/power bars via a diode to make sure components can't draw power through the Arduino if it is the only thing powered, like during flashing.

The Pins are set up to minimise gaps, soldering three three-pin-headers will cover all pins on one side of the Arduino, while connecting the unused RST pin. On the other side just VIN and D13 need to be populated.

On setups with two or more ESCs make sure to only connect the power pin of one of them.

Nano receivers should have dedicated ground and power connectors either in the header or cable - in that case just connect all of them. For other receivers connect the bus, and take ground and power from any other channel.

The following sections contain tables with the pinouts, with the table colums ordered according to the pinout of the component cables.

IBUS receivers have three pin connectors, and only connect to RX. CRSF receivers have four pin connectors, and also connect to TX. The pinouts are for the Arduino Nano Every - on the Nano use RX/TX instead. Note that flashing on the Nano uses RX/TX, so for that board RX should be disconnected on during flashing.

*** LED groups

The Arduino can tolerate about 20mA per pin, with a total of 200mA. One bright 5mm LED draws roughly 20mA - so three sets of two LEDs should be safe to connect directly. For ad-hoc cabling it is sensible to provide a ground pin to connect to a separate ground bar for additional LEDs. When switching LEDs via a transistor it also makes sense to create a power bar.

With insufficient pins, or more/brighter LEDs they should be wired via a transistor. For a small NPN transistor like the 2N3904 you'd connect the base to the Arduino pin through a 4.7kΩ resistor, emitter to GND, and the LED between VCC and the collector.

The default LED pins are in this table:

|             | Pin 1 | Pin 2 |
|-------------+-------+-------|
| status/back | D13   | D2    |
| front       | D11   | D12   |
| effect      | D4    | D5    |

Pin 2 is only relevant when attaching two power hungry LEDs directly for one specific effect, and may have to be explicitly enabled for a specific model.

If a model doesn't incorporate LEDs one status LED should still be visible for safety reasons. This can either be achieved by mounting the Arduino in a way that the on board LED connected to pin 13 becomes visible, or by connecting an extra LED to pin 13.

When incorporating LEDs into a model the status LEDs should be used as the rear lights.

*** ELRS receiver reset

Pin A7 is configured as digital pin, and pulled high on startup. This allows powering the receiver only when the program is running, and power cycling it as needed.

To use this you'll need a NPN transistor like the BD139. Connect the base to A7 through a 1kΩ resistor, emitter to GND, collector to GND of the receiver, and  of the power in of the receiver to VCC.

*** Models
**** Arctic Tinyrider

|          | GND | 5v | arduino | arduino |
|----------+-----+----+---------+---------|
| ESC      | x   | x  | D3      |         |
| receiver | x   | x  | RX1     | TX1     |
| arduino  | x   | x  |         |         |
| servo    | x   | x  | D10     |         |


**** NoTanks

|           | GND | 5v | arduino | arduino |
|-----------+-----+----+---------+---------|
| left ESC  | x   | x  | D3      |         |
| right ESC | x   | x  | D4      |         |
| receiver  | x   | x  | RX1     | TX1     |
| arduino   | x   | x  |         |         |

**** RC Benchy

|          | GND | 5v | arduino | arduino |
|----------+-----+----+---------+---------|
| ESC      | x   | x  | D3      |         |
| receiver | x   | x  | RX1     | TX1     |
| arduino  | x   | x  |         |         |
| servo    | x   | x  | D10     |         |

** Transmitter channels
This section contains tables about channel setups for all tested transmitters, with information on how to set up additional switches, if needed.

*** Default channel mapping for Radiomaster MT12

| Channel | Trigger  | Type            | Comments                               |
|---------+----------+-----------------+----------------------------------------|
|       1 | wheel    |                 |                                        |
|       2 | throttle |                 |                                        |
|       3 | SA       | switch, 3 state | default 1000                           |
|       4 | SB       | button          | default 1000, starts timer per default |
|       5 | P1       | poti            | default 1500                           |
|       6 | P2       | poti            | default 1500                           |
|       7 | SC       | button, 2 state | default 1000                           |
|       8 | SD       | button, 2 state | default 1000                           |

Note that channel 5 for ELRS is typically a 1 bit channel for arming - and as such the first poti mapped to channel 5 is not ideal. This firmware assumes that it got remapped to channel 5, and the expansion module with the two switches got installed and mapped, leading to the following configuration:

| Channel | Trigger  | Type            | Comments                               |
|---------+----------+-----------------+----------------------------------------|
|       1 | wheel    |                 |                                        |
|       2 | throttle |                 |                                        |
|       3 | SA       | switch, 3 state | default 1000                           |
|       4 | SB       | button          | default 1000, starts timer per default |
|       5 | FL1      | switch, 2 state | default 1000, expansion module (front) |
|       6 | P2       | poti            | default 1500                           |
|       7 | SC       | button, 2 state | default 1000                           |
|       8 | SD       | button, 2 state | default 1000                           |
|       9 | P1       | poti            | default 1500                           |
|      10 | FL2      | switch, 2 state | default 1000, expansion module (back)  |

To configure the expansion module

- go to hardware settings, and set S3/S4 to =switch=
- scroll down, and set =FL1= to =S3=, =FL2= to =S4=, both with =2POS=
- go to model settings, mixes page, and change channel 5 to FL1, add channel 9 with S1, and add channel 10 with FL2

*** Default channel mapping for Radiomaster Pocket

| Channel | Trigger                 | Type            | Comments     |
|---------+-------------------------+-----------------+--------------|
|       1 | right stick, left/right |                 |              |
|       2 | right stick, up/down    |                 |              |
|       3 | left stick, up/down     |                 | default 1000 |
|       4 | left stick, left/right  |                 |              |
|       5 | SA                      | switch, 2 state | default 1000 |
|       6 | SB                      | switch, 3 state | default 1000 |
|       7 | SC                      | switch, 3 state | default 1000 |
|       8 | SD                      | switch, 2 state | default 1000 |
|       9 | SE                      | button, 2 state | default 1000 |
|      10 | SI                      | poti            | default 1000 |

*** Default channel mapping for Flysky FS-i6

| Channel | Trigger                 | Type            | Comments     |
|---------+-------------------------+-----------------+--------------|
|       1 | right stick, left/right |                 |              |
|       2 | right stick, up/down    |                 |              |
|       3 | left stick, up/down     |                 | default 1000 |
|       4 | left stick, left/right  |                 |              |
|       5 | VRA                     | poti            | default 1000 |
|       6 | VRB                     | poti            | default 1000 |
|       7 | SWA                     | switch, 3 state | default 1000 |
|       8 | SWB                     | switch, 2 state | default 1000 |
|       9 | SWC                     | switch, 2 state | default 1000 |
|      10 | SWD                     | switch          | default 1000 |

VRA/VRB are configured on channels 5/6 per default in 'aux channel setup', while the switches are not assigned.
